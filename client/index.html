<html>
<head>
<style>
    body {background-color: #141414; color: white; font-family: 'Bangers', cursive; font-size: 22px; margin: 0; }
    .logo { display:inline-block; font-size: 72px; text-align: center; }
    button { padding: 3px 6px 3px 6px; font-size: 22px; font-family: 'Bangers', cursive; text-shadow: 2px 2px #000000; color: white; background-color: dimgrey; }
    p { font-size: 32px; margin: 6px 0 6px 0; text-shadow: 2px 2px #000000; }
    form { margin: 0 0 16px 0; }
    input { height: 28px; text-align: right; }
    button:disabled,
    button[disabled]{
        opacity: 66%;
        color: lightgrey;
    }
    button.tmp-ui {
        border-color: lightgreen;
        background-color: limegreen;
    }
    button.tmp-ui:disabled,
    button.tmp-ui[disabled]{
        border-color: dimgray;
        background-color: darkgray;
    }
</style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bangers&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/gh/ethereum/web3.js/dist/web3.min.js"></script>
    <script>
        let BN = null;
        let toBN = null;
        let rolls = [];
        let elRollParent = null;
        let elStateText = null;
        let elCreateBetButton = null;
        let elCreateBetAmount = null;
        //let elCreateBetPassword = null
        let elJoinBetButton = null;
        let elJoinBetId = null;
        //let elJoinBetPassword = null;
        let elActivateButton = null;
        let elAddressText = null;
        let elPlayerRollButton = null;
        let elOpponentRollButton = null;

        let currentCeil = null;
        let rollCount = null;
        let isAddr1Begin = null;
        let isAddr1 = null;

        let contractAddr = '';
        let contractABI = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"newAdmin","type":"address"}],"name":"AdminAdd","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"oldAdmin","type":"address"}],"name":"AdminRemove","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"oldOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnerSet","type":"event"},{"inputs":[{"internalType":"address","name":"addr","type":"address"}],"name":"addAdmin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"getAdmins","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getOwnerBalance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"isAdmin","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"ownerWithdraw","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"addr","type":"address"}],"name":"removeAdmin","outputs":[],"stateMutability":"nonpayable","type":"function"}]');

        let contract = null;
        let bet = null;
        let user = null;

        let gasPrice = '0';
        let gas = '0';
        let polygonMumbaiChainId = 80001;
        let polygonMainnetChainId = 137;

        let eventSubscription = null;

        let currentChainId = null;
        let currentAccount = null;
        let playingAccount = null;
        //let playingChain = null;
        let currentBet = null;

        let BN_TWO = null;
        let BN_TEN = null;
        let BN_HUNDRED = null;
        let BN_TEN_THOUSAND = null;
        let BN_BET_SANITY = null;

        let BN_CEIL_MIN = null;
        let BN_CEIL_MAX = null;

        let init = async () => {
            if (!window.ethereum) return;

            elRollParent = document.getElementById('roll-text-div');
            elStateText = document.getElementById('state-text');
            elCreateBetButton = document.getElementById('create-bet-button');
            elCreateBetAmount = document.getElementById('create-bet-amount');
            elJoinBetButton = document.getElementById('join-bet-button');
            elActivateButton = document.getElementById('activate-button');
            elAddressText = document.getElementById('address-text');
            elPlayerRollButton = document.getElementById('player-roll-button');
            elOpponentRollButton = document.getElementById('opponent-roll-button');
            elJoinBetId = document.getElementById('join-bet-id');
            //elJoinBetPassword = document.getElementById('join-bet-password');

            let web3 = new Web3(window.ethereum);
            while (!currentAccount || !currentChainId || currentChainId !== polygonMumbaiChainId) {
                try {
                    currentAccount = (await web3.eth.requestAccounts())[0];
                    currentChainId = await web3.eth.getChainId();
                    if (currentChainId !== polygonMumbaiChainId) await ethereum.request({ method: 'wallet_switchEthereumChain', params:[{chainId: web3.utils.numberToHex(polygonMumbaiChainId)}]});
                    elAddressText.innerText = currentAccount;
                } catch (e) {
                    //user canceled or doesn't have metamask/web3
                }
            }

            updateActivateButton();

            BN = web3.utils.BN;
            toBN = web3.utils.toBN;
            BN_TWO = new BN(2);
            BN_TEN = new BN(10);
            BN_HUNDRED = new BN(100);
            BN_TEN_THOUSAND = new BN(10000);
            BN_BET_SANITY = new BN(256).pow(BN_TWO).div(BN_TEN);
            BN_CEIL_MIN = BN_HUNDRED;
            BN_CEIL_MAX = BN_TEN_THOUSAND;

            window.ethereum.on('accountsChanged', function (accounts) {
                currentAccount = accounts[0];
                elAddressText.innerText = currentAccount;
                console.log('accountsChanges',accounts);
            });

            window.ethereum.on('chainChanged', function(chainId){
                console.log('chainChanged',chainId);
                currentChainId = web3.utils.hexToNumber(chainId);
                updateActivateButton();
            });

            elActivateButton.addEventListener('click', () => {
                elJoinBetButton.disabled = elCreateBetButton.disabled = false;
                elActivateButton.disabled = true;
            });

            elCreateBetButton.addEventListener('click', async () => {
                elCreateBetButton.disabled = elJoinBetButton.disabled = true;
                let amount = elCreateBetAmount.value;
                let value = Math.floor(Number(amount));
                if (value === Infinity || String(value) !== amount || value <= 0) {
                    elCreateBetButton.disabled = elJoinBetButton.disabled = false;
                    elStateText.innerHTML = "Invalid bet value";
                    return;
                }

                try {
                    playingAccount = currentAccount;
                    contract = new web3.eth.Contract(contractABI, contractAddr, {
                        from: playingAccount,
                        gasPrice: gasPrice,
                        gas: gas,
                    });

                    let user = {};
                    [user.balance, user.betId, user.fromBlock, user.toBlock] = await contract.methods.getUser().call();
                    let betValue = new BN(web3.utils.toWei('0.1', 'ether'));

                    let receipt; //todo: see if we can use the signing here to auth with instead of a secondary
                    // todo: .. web3.eth.signTransaction(transactionObject, address [, callback]) ->
                    if (user.balance.gte(betValue)) receipt = await contract.methods.createBet(betValue, web3.fromAscii("")).send();
                    else receipt = await contract.methods.createBet(betValue, web3.fromAscii("")).send({ value: betValue.sub(user.balance) });
                    // todo: instead of using event to get betId we can make another call ot getUser after await contract...createBet
                    let betId = receipt.events.BetCreated.returnValues.betId;
                    let fromBlock = receipt.blockNumber;
                    eventSubscription = contract.events.allEvents({ fromBlock: fromBlock, filter: { betId: betId } }, handleEvent);
                } catch (e) {
                    playingAccount = contract = null;
                    elCreateBetButton.disabled = elJoinBetButton.disabled = false;
                    elStateText.innerHTML = "Failed to create bet";
                    console.log(e);
                }

                elStateText.innerHTML = "Bet created";
            });


            elJoinBetButton.addEventListener('click', async () => {
                elCreateBetButton.disabled = elJoinBetButton.disabled = true; //todo: fix ui
                let user = {};
                try {
                    playingAccount = currentAccount;
                    contract = new web3.eth.Contract(contractABI, contractAddr, {
                        from: playingAccount,
                        gasPrice: gasPrice,
                        gas: gas,
                    });
                    [user.balance, user.betId, user.fromBlock, user.toBlock] = await contract.methods.getUser().call();

                    let betIdInput = elJoinBetId.value;
                    let betId = Math.floor(Number(betIdInput)); //making sure it's a number and sane
                    if (betId === Infinity || String(betId) !== betIdInput || betId <= 0) {
                        elStateText.innerHTML = "Invalid Bet ID";
                        elCreateBetButton.disabled = elJoinBetButton.disabled = false;
                        return;
                    }

                    let bet = {};
                    [bet.isAddr1Begin, bet.isConfirmed, bet.addr1, bet.addr2, bet.balance, bet.timestamp, bet.password] = await contract.methods.getBet(betId).call();
                    let receipt;
                    if (user.balance.gte(betValue)) receipt = await contract.methods.joinBet(betId, web3.fromAscii("")).send();
                    else receipt = await contract.methods.joinBet(betId, web3.fromAscii("")).send({value: betValue.toString()});
                    eventSubscription = contract.events.allEvents({ fromBlock: receipt.blockNumber, filter: { betId: betId } }, handleEvent);
                } catch (e) {
                    elStateText.innerHTML = "Failed to join bet";
                    elCreateBetButton.disabled = elJoinBetButton.disabled = false;
                    console.log(e);
                }
                elStateText.innerHTML = "Bet joined";
            });

            elPlayerRollButton.addEventListener('click', async () => {
                elStateText.innerHTML = "Rolling... (to be continued)";
                //todo: call lambda function
            });
        }

        let updateRollTextOpacity = () => {
            for (let i = 0; i < rolls.length; i++) {
                rolls[i].styles.opacity = `${100-(i*10)}%`;
            }
        }
/*
        event BetCanceled(uint indexed betId);
        event BetJoined(uint indexed betId);
        event BetConfirmed(uint indexed betId, bool isAddr1Begin);
        event RollComplete(uint indexed betId, uint rollResult);
        event BetComplete(uint indexed betId, address indexed winner, address indexed loser, uint betValue);*/

        let handleEvent = async (e) => {
            let isMyTurn;
            let ceil;
            switch (e.event) {
                case 'BetCanceled':
                    elStateText.innerHTML = "Bet canceled";
                    currentBet = playingAccount = contract = null;
                    await eventSubscription.unsubscribe();
                    break;
                case 'BetJoined':
                    currentBet = {};
                    [bet.isAddr1Begin, bet.isConfirmed, bet.addr1, bet.addr2, bet.balance, bet.timestamp, bet.password] = await contract.methods.getBet(betId).call();
                    elStateText.innerHTML = "Waiting for opponent";
                    isAddr1 = bet.addr1 === playingAccount;
                    //todo: check in with lambda + show ui waiting for confirmed
                    break;
                case 'BetConfirmed':
                    rollCount = 0;
                    let betAmount = bet.balance.div(2);
                    currentCeil = betAmount.gte(BN_BET_SANITY) ? BN_CEIL_MAX : BN.max(BN_CEIL_MIN, BN.min(betAmount.mul(BN_TEN), BN_CEIL_MAX));

                    isAddr1Begin = e.returnValues.isAddr1Begin; // note that this bool is possibly changed after BetJoined
                    // todo: possibly we can rely purely on events for isAddr1Begin instead of passing it around here
                    isMyTurn = isAddr1Begin && isAddr1;
                    elPlayerRollButton.innerHTML = isMyTurn ? `Roll 0-${ceil}` : 'Waiting';
                    elOpponentRollButton.innerHTML = isMyTurn ? 'Waiting' : `Roll 0-${ceil}`;
                    elPlayerRollButton.disabled = !isMyTurn;

                    elStateText.innerHTML = isMyTurn ? "Your turn" : "";
                    //todo:
                    break;
                    //1 % 2 = 1
                    //2 % 2 = 0
                case 'RollComplete':
                    rollCount++;
                    let result = e.returnValues.rollResult;
                    isMyTurn = isAddr1 && rollCount % 2 === isAddr1Begin ? 0 : 1;
                    elPlayerRollButton.innerHTML = isMyTurn ? `Roll 0-${result}` : 'Waiting';
                    elOpponentRollButton.innerHTML = isMyTurn ? 'Waiting' : `Roll 0-${result}`;
                    elPlayerRollButton.disabled = !isMyTurn;

                    elStateText.innerHTML = isMyTurn ? "Your turn" : "";
                    let p = document.createElement('p');
                    let txt = document.createTextNode(`${!isMyTurn ? 'You' : 'They'} roll ${result} (0-${currentCeil})`);
                    p.style.color = !isMyTurn ? '#6991de' : '#c722b8';
                    p.style.width = '100%';
                    p.appendChild(txt);
                    rolls.push(p);
                    updateRollTextOpacity();

                    currentCeil = result;

                    break;
                case 'BetComplete':
                    rollCount++;
                    isMyTurn = isAddr1 && rollCount % 2 === isAddr1Begin ? 0 : 1;
                    elStateText.innerHTML = !isMyTurn ? "You lose" : "You win!";
                    currentBet = playingAccount = contract = null;
                    await eventSubscription.unsubscribe();
                    break;
            }
            updateActivateButton();
        }

        let updateActivateButton = () => { //todo: fix ui
            let isCorrectChain = currentChainId === polygonMumbaiChainId;
            let isPlaying = playingAccount !== null;
            elActivateButton.disabled = !isCorrectChain && !isPlaying;
            if (!isPlaying) elStateText.innerHTML = !isCorrectChain ? "Connect your Mumbai address" : "";
        }

        //for handling invite links
        let parseLink = () => {
            if (location.pathname !== '/') if (tryParsePath(location.pathname)) return;
            if (location.search !== '?' || location.search !== '') tryParseSearch(location.search);
        }

        let tryParseSearch = (search) => {
            let params = search.substring(1).split('-');
            if (1 > params.length > 2 || params[0] === '') return false;
            let betId = Math.floor(Number(params[0]));
            if (betId === Infinity || String(betId) !== params[0] || betId <= 0) return false;
            elJoinBetId.value = params[0];
            //if (params.length < 2 || params[1] === '' || !params[1].match("^[A-Za-z0-9]+$")) return false;
            //elJoinBetPassword.value = params[1];
            return true;
        }

        let tryParsePath = (path) => {
            let params = document.location.search.charAt(0) === '/' ? path.substring(1).split('-') : path.split('-');
            if (params.length < 1 || params[0] === '') return false;
            let match = Math.floor(Number(params[0]));
            if (match === Infinity || String(match) !== params[0] || match < 1) return false;
            elJoinBetId.value = params[0];
            //if (params.length < 2 || params[1] === '' || !params[1].match("^[A-Za-z0-9]+$")) return false;
            //elJoinBetPassword.value = params[1];
            return true;
        }

        window.onload = async (e) => {
            console.log("hello");
            await init();
            parseLink();
        };

    </script>
</head>
<body>
<div style="height: 100%; width: 1080px; margin:0 auto; display: flex; flex-direction: column; flex-wrap: wrap; background-image: url('img/bg.png'); background-position: bottom;">
    <div class="logo" style="margin-top: 16px;"><img src="img/logo.png"/></div>
    <div id="roll-text-div" style="display: flex; flex-direction: column; justify-content: flex-end; overflow: hidden; flex-basis: 20px; flex-shrink: 1; flex-grow: 1; width: 100%; text-align: center; margin: 0px 0px 16px 0px;"></div>
    <div style="margin: 16px 0px 16px 0px;"><p id="state-text" style="width: 100%; text-align: center; margin: 0px;">Your turn!</p></div>
    <div style="margin: 16px 0 16px 0; display: flex; justify-content: center;"><button id="player-roll-button" style="padding: 6px 12px 6px 12px; background-color: #6991de; border-color: lightblue; color: white; width: 112px; margin-right: 16px;" disabled>Waiting</button><button id="opponent-roll-button" style="margin-left: 16px; padding: 6px 12px 6px 12px; background-color: #c722b8; border-color: pink; width: 112px;" disabled>Waiting</button></div>
    <div style="display: flex; justify-content: center;"><button class="tmp-ui" id="create-bet-button" type="submit" style="width: 68px;" disabled>create</button><label
            for="create-bet-amount"> bet:</label><input id="create-bet-amount" type="number" min="0.1" step="0.1"
            onkeypress="return event.charCode >= 48 && event.charCode <= 57 || event.charCode === 44 || event.charCode === 46" style="width: 342px;"></div>
    <div style="display: flex; justify-content: center;"><button class="tmp-ui" id="join-bet-button"  type="submit" style="width: 68px;" disabled>join</button><label
            for="join-bet-id"> id:</label><input id="join-bet-id" onkeypress="return event.charCode >= 48 && event.charCode <= 57" style="width: 352px;"></div>
    <button class="tmp-ui" id="activate-button" style="margin: 16px auto 16px auto; width: 120px;" disabled>activate</button>
    <p id="address-text" style="margin: 0; font-family: 'Times New Roman', Times, serif; font-size: 22px; text-align: center;">0x0</p>
</div>
</body>
</html>